.carouselWrapper {
  position: relative;
  overflow: hidden;
  margin: auto;
  box-sizing: border-box;
}

.imgWrap {
  position: "absolute";
  top: 0;
  left: 0;
}
.imgWrap:hover {
  cursor: pointer;
}
li {
  list-style-type: none;
  left: 40%;
}
.dn {
  display: none;
}
/* // const [currFirstImg, setCurrFirstImg] = useState(0); // The Current Middle Element/Primary element of our carousel
  // const [actualFirst, setActualFirst] = useState(""); // The Clicked Image when it is not the Immediate Next or Immediate Previous Image
  // const currMiddleImgRef = useRef(0); // Reference for the image that is in the middle
  // const imgDifference = useRef(1); // The difference between the middle image and the image that is clicked by user to view next
  // const [visibleItemsProps, setVisibleItemsProps] = useState({
  //   order: [],
  //   styles: {}
  // }); // Set Styles and ordering to Images currently visible
  // const elementsInLeft = Math.ceil(properties.length / 2); // Floor is done to also include middle image along with other images to its left.
  // const elementsInRight = properties.length - elementsInLeft;
  // const img_width = 296;
  // const initialSetting = () => {
  //   console.log(properties);
  //   const visibleItemsProps = {};
  //   visibleItemsProps.order = [];
  //   let timesToIterate = 0;
  //   let curr_center = currFirstImg;
  //   let rightEltCount = elementsInRight;
  //   let leftEltCount = elementsInLeft; // including middle element
  //   let curr_center_copy = curr_center;

  //   let xTranslate = img_width;
  //   const division = img_width * (1.66 / elementsInLeft);

  //   while (timesToIterate < properties.length) {
  //     const styles = {};
  //     let currImgIndex;
  //     let currImgIndexOnRight = true; // Tells if in this iteration the currently iterated image lies left to the middle image or not
  //     if (timesToIterate < elementsInRight) {
  //       const nextIndex = curr_center - rightEltCount;
  //       currImgIndex =
  //         nextIndex > -1 ? nextIndex : properties.length - Math.abs(nextIndex);
  //       xTranslate = 0;
  //       console.log("right true");
  //       rightEltCount--;
  //     } else {
  //       currImgIndexOnRight = false;
  //       currImgIndex = curr_center_copy;
  //       if (curr_center_copy + 1 >= properties.length) {
  //         // to maintain cyclic carousel
  //         curr_center_copy = 0;
  //       } else {
  //         curr_center_copy++;
  //       }
  //       console.log("right false");
  //       xTranslate = 0;
  //     }
  //     styles.transform = `translateX(${xTranslate}px)`;
  //     visibleItemsProps.order.push(currImgIndex); // Push the current image number in the orders array
  //     visibleItemsProps[currImgIndex] = { styles }; // pushing all previously created styles
  //     console.log(visibleItemsProps.order, xTranslate);
  //     timesToIterate++;
  //   }
  //   setVisibleItemsProps(visibleItemsProps);
  // };
  // const changeCenter = index => {
  //   const currFirstImgIndex = visibleItemsProps.order.indexOf(currFirstImg);
  //   const prevIndex = visibleItemsProps.order[currFirstImgIndex - 1];
  //   const nextIndex = visibleItemsProps.order[currFirstImgIndex + 1];
  //   if (index === prevIndex || index === nextIndex) {
  //     // if immediate first/next image
  //     setCurrFirstImg(index);
  //   } else {
  //     const val = currFirstImgIndex - visibleItemsProps.order.indexOf(index);
  //     console.log(visibleItemsProps.order.indexOf(index), val);
  //     imgDifference.current = Math.abs(val); // Gives the number of images we have to cycle through, so we can provide equal part of total duration to all images.
  //     setActualFirst(index);
  //     cycleToNextImage(index);
  //   }
  //   console.log(
  //     "currFirstImgIndex : " + currFirstImgIndex,
  //     "index : " + index,
  //     "prevIndex : " + prevIndex,
  //     "nextIndex : " + nextIndex,
  //     "currFirstImg : " + currFirstImg,
  //     currMiddleImgRef,
  //     imgDifference
  //   );
  // };
  // // To show the subsequent image based on if the user has clicked on the right side or on the left side of the middle image
  // const cycleToNextImage = actual => {
  //   if (
  //     visibleItemsProps.order.indexOf(currMiddleImgRef.current) >
  //     visibleItemsProps.order.indexOf(actual)
  //   ) {
  //     // Right side image click
  //     currMiddleImgRef.current =
  //       currMiddleImgRef.current - 1 > -1
  //         ? currMiddleImgRef.current - 1
  //         : properties.length - 1; // Right side image click
  //     setCurrFirstImg(currMiddleImgRef.current);
  //   } else {
  //     // Left side image click
  //     currMiddleImgRef.current =
  //       currMiddleImgRef.current + 1 < properties.length
  //         ? currMiddleImgRef.current + 1
  //         : 0; // Conditions to handle cycle
  //     setCurrFirstImg(currMiddleImgRef.current);
  //   }
  // };
  // useEffect(() => {
  //   initialSetting();
  //   currMiddleImgRef.current = currFirstImg;
  //   console.log(visibleItemsProps, currMiddleImgRef);
  // }, [currFirstImg]); */
